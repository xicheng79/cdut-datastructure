# 实验4 - 串的模式匹配
***参考代码请前往[百度网盘](https://pan.baidu.com/s/1lAU_YlNtljSCk_uA-ZudjQ)下载***，提取码：cdut
## 1. 串的定义
以顺序存储形式将串定义为 char类型的数组，并**将第1个单元用于存放串的长度**，因此需要分配 length+1个单元
```c++
#define MAX_STR_LEN 255						// 用户可在 255(1 个字节)以内定义最大串长
typedef char SString[MAX_STR_LEN + 1];		// 0 号单元存放串的长度
```
在此基础上实现串的操作
```c++
1. StrAssign 	//生成一个其值等于chars的串T
2. StrPrint		//在屏幕上显示串的内容
3. StrLength    //返回串的长度
4. bool Concat(SString T, SString S1, SString S2) //S1和S2联接为新串T，若联接长度不超过MaxLength则返回TRUE，否则截断串并返回FALSE
```
## 2. 模式匹配的实现
```c++
//BF算法：返回模式T在主串S中第pos个字符之后第s一次出现的位置。若不存在，则返回值为0。其中，T非空，1≤pos≤StrLength(S)
1. int Index_BF(SString S, SString T, int pos) 
//算法4.2　KMP算法
//利用模式串T的next函数求T在主串S中第pos个字符之后的位置的KMP算法。其中，T非空，1≤pos≤StrLength(S)
2. int Index_KMP(SString S, SString T, int pos, int next[])
//Index_KMP()算法需要的两个函数
//算法4.3　 求模式串T的next函数值并存入数组next
3. void get_next(SString T, int next[])
//算法4.4   求模式串T的next函数修正值并存入数组nextval
5. void get_nextval(SString T, int nextval[])
```
最后在主函数中调用以上操作，完成串的模式匹配实验
```c++
int main()
{
	int i, *next;
	char ch1[80], ch2[80];
	SString S1, S2, S, SUB;					// 定义串，第一个单元存储串的长度
	cout << "请输入第一个字符串:";
	cin >> ch1;
	StrAssign(S1, ch1);
	StrPrint(S1);
	
	cout << "请输入第二个字符串:";
	cin >> ch2;
	StrAssign(S2, ch2);
	StrPrint(S2);
	cout << "------------------------------------------------\n";
	cout << "第一个字符串长度为： " << StrLength(S1) << endl;
	cout << "第二个字符串长度为： " << StrLength(S2) << endl;
	
	cout << "\n============连接两个字符串构造主串==============\n";
	Concat(/*----补充参数-----*/); //用 S 返回 S1 和 S2 联接而成的新串
	cout << "主串长度为： " << StrLength(S) << endl;
	cout << "主串为： ";
	StrPrint(S);
	cout << "请输入子串:";
	cin >> ch2;
	StrAssign(SUB, ch2);
	cout << "子串长度为： " << StrLength(SUB) << endl;

	cout << "\n---------------BF 匹配算法及实现----------------\n";
	i = Index_BF(S, SUB, 1);			// 利用算法 4.6 求得串 s2 在 s1 中首次匹配的位置 i
	if (i)
		printf("主串和子串在第%d 个字符处首次匹配\n", i);
	else
		printf("主串和子串匹配不成功\n");

	cout << "\n---------------KMP 匹配算法及实现---------------\n";
	next = new int[StrLength(SUB) + 1];
	get_next(SUB, next);			// 利用算法 4.7，求得 next 数组，存于 next 中
	printf("子串的 next 数组为: ");
	for (i = 1; i <= StrLength(SUB); i++)
		cout << *(next + i);
	printf("\n");
	i = Index_KMP(/*----补充参数-----*/);		// 利用算法 4.6 求得串 s2 在 s1 中首次匹配的位置
	if (i)
		printf("主串和子串在第%d 个字符处首次匹配\n", i);
	else
		printf("主串和子串匹配不成功\n");

	cout << "\n--------------KMP改进匹配算法及实现-------------\n";
	get_nextval(SUB, next);			    		// 利用算法 4.8，求得 next 数组，存于 next 中
	printf("子串的 nextval 数组为: ");
	for (i = 1; i <= StrLength(SUB); i++)
		cout << *(next + i);
	printf("\n");
	i = Index_KMP(/*----补充参数-----*/);		// 利用算法 4.6 求得串 s2 在 s1 中首次匹配的位置 i
	if (i)
		printf("主串和子串在第%d 个字符处首次匹配\n", i);
	else
		printf("主串和子串匹配不成功\n");
	
	getchar();
	return 0;
}
```
***参考代码请前往[百度网盘](https://pan.baidu.com/s/1lAU_YlNtljSCk_uA-ZudjQ)下载***，提取码：cdut

