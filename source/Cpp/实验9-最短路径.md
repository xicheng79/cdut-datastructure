# 实验9 - 最短路径

## 1.  实验内容
1. 从文件中读入有向图（网）并以邻接矩阵存储。
2. 利用杰斯特拉算法寻求最短路径（弗洛伊德算法及实现自学完成）
## 2. 图的输入
图的输入： 图见教材P171 图 6.22， 采用文件输入方式，具体为
```javascript
6 8
a b c d e f
a f 100
a b 10
a c 30
b c 5
c d 50
e d 20
e f 60
```
## 3. 算法实现
### 1. 本实验涉及到以下函数
```c++
1) main() //主函数  
2) int LocateVex(ALGraph G , VerTexType v) //确定点 v 在 G 中的位置  
3) int  CreateUDG(ALGraph &G) //创建图 G 的邻接表、逆邻接表  
4) void DisplayPath(AMGraph G ,  int  begin ,int temp ) // 显示最短路径
5) void ShortestPath_DIJ(AMGraph G, int v0)  // 用 Dijkstra 算法求有向网 G 的 v0 顶点到其余顶点的最短路径
```
### 2. 算法实现
1. main函数逻辑
![算法的主要逻辑](https://i.bmp.ovh/imgs/2021/10/7178176f05ddd2aa.png)

2. ShortestPath_DIJ函数

**数组S[n]**：记录从源点v0到终点vi是否已被确定最短距离。true为确定/false尚未确定
**数组D[n]**：记录源点v0到终点vi当前的最短路径长度。初值：arc[v0][vi] / ∞
**数组Path[n]**：记录源点v0到终点vi的当前最短路径上的vi的前驱顶点。 v0 / -1

DijKstra算法初始化
[![IpnQw8.png](https://z3.ax1x.com/2021/10/31/IpnQw8.png)](https://imgtu.com/i/IpnQw8)

DijKstra算法主循环
/*―初始化结束，开始主循环，每次求得v0到某个顶点v的最短路径，将 v加到 S集―*/
[![IpnYSs.md.png](https://z3.ax1x.com/2021/10/31/IpnYSs.md.png)](https://imgtu.com/i/IpnYSs)

DijKstra算法流程图
[![IpnNyq.md.png](https://z3.ax1x.com/2021/10/31/IpnNyq.md.png)](https://imgtu.com/i/IpnNyq)
