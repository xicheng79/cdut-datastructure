# 实验9 - 最短路径

## 1.  实验内容
1. 从文件中读入有向图（网）并以邻接矩阵存储。
2. 利用杰斯特拉算法寻求最短路径（弗洛伊德算法及实现自学完成）
## 2. 图的输入
图的输入： 图见教材P171 图 6.22， 采用文件输入方式，具体为
```javascript
6 8
a b c d e f
a f 100
a b 10
a c 30
b c 5
c d 50
e d 20
e f 60
```
## 3. 算法实现
### 1. 本实验涉及到以下函数
```c++
1) main() //主函数  
2) int LocateVex(ALGraph G , VerTexType v) //确定点 v 在 G 中的位置  
3) int  CreateUDG(ALGraph &G) //创建图 G 的邻接表、逆邻接表  
4) void DisplayPath(AMGraph G ,  int  begin ,int temp ) // 显示最短路径
5) void ShortestPath_DIJ(AMGraph G, int v0)  // 用 Dijkstra 算法求有向网 G 的 v0 顶点到其余顶点的最短路径
```
### 2. 算法实现
1. main函数逻辑
![算法的主要逻辑](https://i.bmp.ovh/imgs/2021/10/7178176f05ddd2aa.png)

2. ShortestPath_DIJ函数
**数组S[n]**：记录从源点v0到终点vi是否已被确定最短距离。true为确定/false尚未确定
**数组D[n]**：记录源点v0到终点vi当前的最短路径长度。初值：arc[v0][vi] / ∞
**数组Path[n]**：记录源点v0到终点vi的当前最短路径上的vi的前驱顶点。 v0 / -1

DijKstra算法初始化
![输入图片描述](%E5%AE%9E%E9%AA%8C9-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84_md_files%5C9-2.DIJ%E5%87%BD%E6%95%B0.png?v=1&type=image)

DijKstra算法主循环
/*―初始化结束，开始主循环，每次求得v0到某个顶点v的最短路径，将 v加到 S集―*/
![输入图片描述](%E5%AE%9E%E9%AA%8C9-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84_md_files%5C9-2.DIJ%E5%87%BD%E6%95%B0-%E4%B8%BB%E5%BE%AA%E7%8E%AF.png?v=1&type=image)

DijKstra算法流程图
![输入图片描述](%E5%AE%9E%E9%AA%8C9-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84_md_files%5C9-2.DIJ%E5%87%BD%E6%95%B0-%E6%B5%81%E7%A8%8B.png?v=1&type=image)
