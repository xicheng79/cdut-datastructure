# 实验8 - 图的最小生成树

## 1. 实验内容
1. 从文件中读入无向图（网）并以邻接矩阵存储。
2. **利用普里姆算法构造最小生成树（克鲁斯卡尔算法及实现自学完成）**

## 2. 图的输入
图的输入： 图见教材P166 图 6.19(a)， 采用文件输入方式，具体为
```javascript
6 10
a b c d e f 
a b 6
a c 1
a d 5
b c 5
b e 3
c d 5
c e 6
c f 4 
d f 2
e f 6
```
其中6为顶点数，8为边数

## 3. 算法实现
### 1. 辅助数组定义
```c++
//辅助数组的定义，用来记录从顶点集U到V-U的权值最小的边
struct {
  VerTexType  adjvex; 	//最小边在U中的那个顶点
  ArcType  lowcost; 	//最小边上的权值
}closedge[MVNum];
```
### 2. 本实验涉及到以下函数
```c++
//辅助数组的定义，用来记录从顶点集U到V-U的权值最小的边
1) main() //主函数  
2) int  LocateVex(ALGraph G , VerTexType v) //确定点 v 在 G 中的位置  
3) int  CreateUDG(ALGraph &G) //创建图 G 的邻接表、逆邻接表  
4) int Min(AMGraph G) //返回权值最小的点  
5) void MiniSpanTree_Prim(AMGraph G, VerTexType u) //prim
```

### 3. 算法步骤
1. 初始化 辅助数组 lowcost 和 adjvex；
2. 输出顶点u0，将顶点u0加入集合U中；
3. 重复执行下列操作n-1次
  3.1 在lowcost中选取最短边，取adjvex中对应的顶点序号k；
  3.2 输出顶点k和对应的权值；
  3.3 将顶点k加入集合U中；
  3.4 调整数组lowcost和adjvex；
```c++
void MiniSpanTree_Prim(AMGraph G, VerTexType u) {
  //无向网G以邻接矩阵形式存储，从顶点u出发构造G的最小生成树T，输出T的各条边  
  int k, j, i;
  VerTexType u0, v0;
  k = LocateVex(G, u);  		//k为顶点u的下标 
  for (j = 0; j < G.vexnum; ++j) { //对V-U的每一个顶点vi，初始化closedge[i] 
	if (j != k) {
      closedge[j].adjvex = u;
	  closedge[j].lowcost = G.arcs[k][j];	//{adjvex, lowcost}
	  }//if
  }//for
  closedge[k].lowcost = 0;        	//初始，U = {u}
  for (i = 1; i < G.vexnum; ++i) {  	//选择其余n-1个顶点，生成n-1条边(n= G.vexnum) 
	k = Min(G);    		//求出T的下一个结点：第k个顶点，closedge[k]中存有当前最小边 
	u0 = closedge[k].adjvex; 		//u0为最小边的一个顶点，u0∈U 
	v0 = G.vexs[k];          		//v0为最小边的另一个顶点，v0∈V-U 
	cout << "边  " << u0 << "--->" << v0 << endl;       //输出当前的最小边(u0, v0) 
	closedge[k].lowcost = 0;   		//第k个顶点并入U集 
	for (j = 0; j < G.vexnum; ++j)
   	  if (G.arcs[k][j] < closedge[j].lowcost) {	 //新顶点并入U后重新选择最小边 
		//调整数组lowcost和adjvex
		closedge[j].adjvex = G.vexs[k];
		closedge[j].lowcost = G.arcs[k][j];
	  }//if 
   }//for 
}
```
