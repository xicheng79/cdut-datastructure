# 实验7 - 图的综合运算

***参考代码请前往[百度网盘](https://pan.baidu.com/s/1lAU_YlNtljSCk_uA-ZudjQ)下载***，提取码：cdut

## 1. 实验内容
1. 完成图的顺序与链式存储
2. **实现图的初始化、 构建与遍历等基本运算**，分别采用 邻接矩阵 和 邻接表 实现（即两个cpp）

## 2. 图的输入
图的输入： 图见 P161 图 6.17(a)， 采用文件输入方式，具体为
```javascript
8 9
a b c d e f g h
a b 1
a c 1
b d 1
b e 1
d h 1
e h 1
c f 1 
c g 1
f g 1
```
其中8为顶点数，9为边数

## 3. 算法实现
1. 主函数逻辑
```c++
int main()
{
  Graph G;
  //1.函数内部通过读取 tu.txt 文件创建图，算法6.2+算法6.3
  CreateUDN(G);  
  //2.输入起点c	
  //判断输入c是否合理，如不合理，重新输入；
  //如合理，计算c应为第i个顶点 （注意：邻接矩阵和邻接表求i的方式不一样！）
  
  //3. 深度优先遍历
  DFS(G , i);

  //4. 广度优先遍历
  BFS(G , i);
}
```
2. 邻接矩阵存储时的预定义与图结构定义
```c++
#include <iostream>
#include<fstream>
using namespace std;
#define OK 1
#define ERROR 0
#define OVERFLOW -2
#define MVNum 100 //最大顶点数
#define MAXQSIZE 100 //最大队列长度

typedef char  VerTexType; 	//假设顶点的数据类型为字符型
typedef int  ArcType; 		//假设边的权值类型为整型
bool  visited[MVNum]; 		//访问标志数组，其初值为“false”

//-----图的邻接矩阵存储表示----- 
typedef struct{ 
  VerTexType vexs[MVNum]; 		//顶点表
  ArcType arcs[MVNum][MVNum];  	//邻接矩阵
  int vexnum,arcnum;            //图的当前点数和边数
}Graph;
```
3. 邻接表存储时的预定义与图结构定义
```c++
#include <iostream>
#include<fstream>
using namespace std;
#define OK 1
#define ERROR 0
#define OVERFLOW -2
#define MVNum 100 		//最大顶点数
#define MAXQSIZE 100 	//最大队列长度

typedef char  VerTexType; 	//假设顶点的数据类型为字符型
typedef int  ArcType; 		//假设边的权值类型为整型
bool  visited[MVNum]; 		//访问标志数组，其初值为“false”

//-------------图的邻接表---------------------
typedef struct  ArcNode{ 	//边结点
  int adjvex; 				//该边所指向的顶点的位置
  struct  ArcNode  *nextarc; 	//指向下一条边的指针
}ArcNode;

typedef struct  VNode{
  VerTexType data; 		//顶点信息
  ArcNode  *firstarc; 	//指向第一条依附该顶点的边的指针
}VNode, AdjList[MVNum]; //AdjList  表示邻接表类型

typedef struct{
  AdjList  vertices; 	//邻接表
  int vexnum, arcnum; //图的当前顶点数和边数
}ALGraph
```
4. 邻接表存储时的广度优先遍历函数定义
```c++
void BFS(ALGraph  G,int v)
{
  sqQueue Q;
  ArcNode *p;
  ArcType u;
  cout << G.vertices[v].data << " ";
  visited[v]=true; ; /*置已访问标记*/
  InitQueue(Q);
  EnQueue(Q, v); /*访问过的顶点入队列*/
  while(!QueueEmpty(Q))
  {
      DeQueue(Q, u);  /*顶点出队列*/
      p= G.vertices[u].firstarc; /*找到 v 的第一个邻接点*/
      while(p!=NULL)  /*判断邻接点是否存在*/
     {
       if(!visited[p->adjvex]) /*邻接点存在未被访问*/
      {
         cout << p->adjvex << " ";
         visited[p->adjvex]=true; /*置已访问标志*/
         EnQueue(Q,p->adjvex); /*邻接点入队列*/
      }
      p=p->nextarc; /*沿着 v 的邻接点链表顺序搜索*/
    }
  }
}
```
***参考代码请前往[百度网盘](https://pan.baidu.com/s/1lAU_YlNtljSCk_uA-ZudjQ)下载***，提取码：cdut
