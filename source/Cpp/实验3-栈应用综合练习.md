# 实验3 - 栈应用综合练习
***参考代码请前往[百度网盘](https://pan.baidu.com/s/1QEcHa1MNusADOFCnI0c7QQ)下载***，提取码：cdut
## 1. 表达式相关

 ### 1.1  算术四则运算规则
 -  先乘除,后加减
 - 从左算到右
 - 先括号内,后括号外

 ### 1.2 表达式
 - 操作数(operand)
	 - 常数
	 - 标识符
 - 运算符(operator)
	 - 算术
	 - 逻辑
	 - 关系
- 界限符(delimiter)
	- 括号
	- 结束符

### 1.3 算符间的优先关系
![输入图片描述](https://i2.wp.com/img-blog.csdnimg.cn/20200516200315885.png)

## 2. 算法步骤
**设定两栈 ：** 
 -  **OPND** --- 用于存取操作数或运算结果　
 -  **OPTR** --- 用于存取运算符
 
 1. 初始化OPTR栈和OPND栈，将表达式起始符“#” 压入OPTR栈
 2. 扫描表达式，读入第一个字符ch，如果表达式 ***没有扫描完毕至 “#”*** 或 ***OPTR的栈顶元素不为“#”*** 时，则循环执行以下操作：
	 -  **若ch不是运算符**，则压入OPND栈，读入下一字符ch；
	 -  **若ch是运算符**，则根据 OPTR的栈顶元素和ch的优先级比较结果，做不同的处理：
		 -  ***若是小于***，则ch压入OPTR栈，读入下一字符ch；
		 -  ***若是大于***，则弹出OPTR栈顶的运算符，从OPND栈弹出两个数，进行相应运算，结果压入OPND栈；
		 -  ***若是等于***，则OPTR的栈顶元素是 “(” 且 ch是 “)” ，这时弹出OPTR栈顶的“(”，相当于括号匹配成功，然后读入下一字符ch。
3. **OPND栈顶元素**即为表达式求值结果，返回此元素。

## 3. 代码实现

```C++
OperandType  EvaluateExpression() {
  InitStack (OPTR);  Push (OPTR，'#') ;
  InitStack (OPND); ch = getchar( );
  while (ch!= '#' || GetTop(OPTR)! = '#') {
    if (! In(ch)){
      Push(OPND,ch); ch = getchar(); }  // ch不是运算符则进栈
   else {	
	  switch (Precede(GetTop(OPTR),ch)) {  //比较优先权
      case '<' :   //当前字符ch压入OPTR栈，读入下一字符ch
		Push(OPTR, ch); ch = getchar();  break;
	  case '>' :  //弹出OPTR栈顶的运算符运算，并将运算结果入栈
		Pop(OPTR, theta);
		Pop(OPND, b);  Pop(OPND, a);
		Push(OPND, Operate(a, theta, b)); break;
	case '=' :  //脱括号并接收下一字符
		Pop(OPTR,x); ch = getchar();  break;
	} // switch
  } //	else
} // while
return GetTop(OPND);} // EvaluateExpression
```
***注意：*** 需要在栈操作的基础上自行实现 Precede() 和 Operate() 两个函数

***参考代码请前往[百度网盘](https://pan.baidu.com/s/1QEcHa1MNusADOFCnI0c7QQ)下载***，提取码：cdut

